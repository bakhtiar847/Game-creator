<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Player — Objects & Overlay</title>
	<style>
		:root{--bg:#0f1721;--card:#0b1220;--accent:#06b6d4;--muted:#94a3b8}
		html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;color:#e6eef6;background:linear-gradient(180deg,#071022 0%,#071a2a 100%)}
		.container{display:flex;flex-direction:column;height:100vh}
		header{padding:12px 16px;display:flex;align-items:center;gap:12px}
		h1{font-size:18px;margin:0;color:var(--accent)}
		.toolbar{margin-left:auto;display:flex;gap:8px}
		button{background:var(--card);border:1px solid rgba(255,255,255,0.04);color:#dff7ff;padding:8px 10px;border-radius:8px;cursor:pointer}
		main{flex:1;display:flex;gap:12px;padding:12px}
		/* game area */
		.stage{flex:1;background:rgba(255,255,255,0.02);border-radius:10px;position:relative;overflow:hidden;border:1px solid rgba(255,255,255,0.03)}
		.grid{position:absolute;inset:0;background-image:linear-gradient(rgba(255,255,255,0.01) 1px, transparent 1px),linear-gradient(90deg,rgba(255,255,255,0.01) 1px, transparent 1px);background-size:40px 40px,40px 40px}
		.obj{position:absolute;width:56px;height:56px;border-radius:8px;display:flex;align-items:center;justify-content:center;color:#041826;font-weight:700;cursor:pointer;box-shadow:0 4px 12px rgba(2,6,23,0.6);transform:translate(-50%,-50%)}
		/* overlay */
		.overlay{position:fixed;right:16px;top:16px;width:320px;max-width:calc(100% - 40px);background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0.02));backdrop-filter:blur(6px);border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.04)}
		.overlay h2{margin:0 0 8px 0;font-size:15px;color:var(--accent)}
		.overlay .meta{font-size:13px;color:var(--muted);margin-bottom:8px}
		.object-list{display:flex;flex-direction:column;gap:6px;max-height:220px;overflow:auto}
		.object-row{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);cursor:pointer}
		.object-color{width:32px;height:32px;border-radius:6px;flex:0 0 32px}
		.muted{color:var(--muted);font-size:13px}
		footer{padding:8px 16px;font-size:13px;color:var(--muted)}
		@media (max-width:600px){.overlay{position:fixed;left:8px;right:8px;top:auto;bottom:8px;width:auto}}
	</style>
</head>
<body>
	<div class="container">
		<header>
			<h1>Player — Objects Preview</h1>
			<div class="toolbar">
				<button id="addBtn">Add random object</button>
				<button id="toggleOverlay">Toggle overlay</button>
			</div>
		</header>

		<main>
			<section class="stage" id="stage" aria-label="Game stage">
				<canvas id="canvas" aria-label="3D canvas renderer"></canvas>
				<div class="grid" aria-hidden="true"></div>
			</section>

			<!-- overlay: object details + list -->
			<aside class="overlay" id="overlay">
				<h2>Objects</h2>
				<div class="meta">Click an object on the stage to view details here.</div>
				<div class="object-list" id="objectList" role="list"></div>
				<div style="margin-top:8px;display:flex;gap:8px;justify-content:space-between;align-items:center">
					<div class="muted" id="selectedInfo">No selection</div>
					<div style="display:flex;gap:8px">
						<button id="centerBtn">Center selected</button>
						<button id="clearBtn">Clear objects</button>
					</div>
				</div>
			</aside>
		</main>

		<footer>
			This demo renders an objects array and shows an overlay with details. Open this file in a browser to interact.
		</footer>
	</div>

	<script>
		// Objects now have richer structure:
		// { id, name, x,y,z (origin), triangles: [{p1:{x,y,z}, p2, p3}], tetrahedrons: [{a,b,c,d}], actions: [{key,name}], flags: isplayer,isworld,iswall }
		let objects = [
			{
				id:1,
				name:'Player',
				x:300,y:100,z:200,
				triangles:[],
				tetrahedrons:[],
				actions:[],
				isplayer:true
			},
			{
				id:2,
				name:'Wall',
				x:500,y:0,z:400,
				triangles:[],
				// simple tetrahedron (four points) in world coords
				tetrahedrons:[
					{a:{x:480,y:0,z:380},b:{x:520,y:0,z:380},c:{x:520,y:100,z:420},d:{x:480,y:100,z:420}}
				],
				actions:[{key:'q',name:'inspect'}],
				isworld:true,
				iswall:true,
				color:'#94a3b8',
				description:'A simple wall tetrahedron'
			},
			{
				id:3,
				name:'Chest',
				x:300,y:0,z:500,
				triangles:[],
				tetrahedrons:[{a:{x:280,y:0,z:480},b:{x:320,y:0,z:480},c:{x:320,y:60,z:520},d:{x:280,y:60,z:520}}],
				actions:[{key:'q',name:'open'}, {key:'z',name:'special'}],
				isworld:false,
				iswall:false,
				color:'#f59e0b',
				description:'A treasure chest with loot.'
			}
		];

		// find player reference and set up player physics state
		let player = objects.find(o=>o.isplayer);
		if(!player){
			player = {id:0,name:'Player',x:300,y:100,z:200,triangles:[],tetrahedrons:[],actions:[],isplayer:true};
			objects.unshift(player);
		}
		player.vel = {x:0,y:0,z:0};
		player.speed = 120; // units per second
		player.jumpImpulse = 320;
		player.onGround = false;

		// input state
		const keysDown = new Set();

		// simple inventory
		let inventoryOpen = false;


		const stage = document.getElementById('stage');
		const canvas = document.getElementById('canvas');
		const ctx = canvas.getContext('2d');
		const objectList = document.getElementById('objectList');
		const overlay = document.getElementById('overlay');
		const toggleOverlayBtn = document.getElementById('toggleOverlay');
		const addBtn = document.getElementById('addBtn');
		const clearBtn = document.getElementById('clearBtn');
		const centerBtn = document.getElementById('centerBtn');
		const selectedInfo = document.getElementById('selectedInfo');

		let selectedId = null;

		// ---------- Canvas 3D renderer (software, from-scratch) ----------
		function resizeCanvas(){
			const dpr = window.devicePixelRatio || 1;
			canvas.width = Math.max(300, stage.clientWidth) * dpr;
			canvas.height = Math.max(150, stage.clientHeight) * dpr;
			canvas.style.width = stage.clientWidth + 'px';
			canvas.style.height = stage.clientHeight + 'px';
			ctx.setTransform(dpr,0,0,dpr,0,0);
		}

		const Camera = function(){
			this.x = 0; this.y = 0; this.z = -700; // camera placed behind origin
			this.rotX = 0; this.rotY = 0; // radians
			this.fov = 60; // degrees
			this.focal = 1 / Math.tan((this.fov/2) * Math.PI/180) * 500; // rough focal length
		}

		Camera.prototype.updateFocal = function(){
			this.focal = 1 / Math.tan((this.fov/2) * Math.PI/180) * 500;
		}

		const camera = new Camera();

		function project(obj){
			// world coords (x,y,z) -> camera coords -> rotate -> perspective -> screen
			const cx = canvas.width/2 / (window.devicePixelRatio||1);
			const cy = canvas.height/2 / (window.devicePixelRatio||1);

			// translate relative to camera position
			let x = obj.x - camera.x;
			let y = obj.y - camera.y;
			let z = obj.z - camera.z;

			// rotate Y (around vertical axis)
			const cosY = Math.cos(camera.rotY), sinY = Math.sin(camera.rotY);
			let rx = x * cosY - z * sinY;
			let rz = x * sinY + z * cosY;

			// rotate X
			const cosX = Math.cos(camera.rotX), sinX = Math.sin(camera.rotX);
			let ry = y * cosX - rz * sinX;
			rlz = y * sinX + rz * cosX;

			// if behind camera, mark as culled
			if(rlz <= 5) return null;

			const scale = camera.focal / rlz;
			return {
				x: cx + rx * scale,
				y: cy + ry * scale,
				scale: scale,
				z: rlz
			};
		}

		// ---------- collision helpers ----------
		// signed volume of tetrahedron (a,b,c,d)
		function signedTetraVolume(a,b,c,d){
			const ax = a.x-d.x, ay = a.y-d.y, az = a.z-d.z;
			const bx = b.x-d.x, by = b.y-d.y, bz = b.z-d.z;
			const cx = c.x-d.x, cy = c.y-d.y, cz = c.z-d.z;
			return (ax * (by*cz - bz*cy) - ay * (bx*cz - bz*cx) + az * (bx*cy - by*cx)) / 6;
		}

		function pointInTetra(pt, tet){
			// using barycentric volumes: point is inside if all sub-volumes have same sign and sum equals vol
			const v = signedTetraVolume(tet.a,tet.b,tet.c,tet.d);
			const v0 = signedTetraVolume(pt,tet.b,tet.c,tet.d);
			const v1 = signedTetraVolume(tet.a,pt,tet.c,tet.d);
			const v2 = signedTetraVolume(tet.a,tet.b,pt,tet.d);
			const v3 = signedTetraVolume(tet.a,tet.b,tet.c,pt);
			// allow small epsilon
			const eps = 1e-6;
			return Math.abs(v - (v0+v1+v2+v3)) < 1e-3 && ((v0>=-eps && v1>=-eps && v2>=-eps && v3>=-eps) || (v0<=eps && v1<=eps && v2<=eps && v3<=eps));
		}

		function isBlockedByWorld(pos){
			// pos: {x,y,z}
			for(const obj of objects){
				if(!(obj.isworld || obj.iswall)) continue;
				if(!obj.tetrahedrons) continue;
				for(const tet of obj.tetrahedrons){
					if(pointInTetra(pos,tet)) return true;
				}
			}
			return false;
		}

		function renderStage(){
			resizeCanvas();
			ctx.clearRect(0,0,canvas.width,canvas.height);

			// camera follows player (behind)
			camera.x = player.x;
			camera.y = player.y + 40; // eye height above player origin
			camera.z = player.z - 160; // behind player

			// project and draw world tetrahedrons (wireframe) first
			for(const obj of objects){
				if(obj.tetrahedrons && obj.tetrahedrons.length){
					for(const tet of obj.tetrahedrons){
						// draw 4 triangular faces
						const faces = [
							[tet.a,tet.b,tet.c],
							[tet.a,tet.b,tet.d],
							[tet.a,tet.c,tet.d],
							[tet.b,tet.c,tet.d]
						];
						for(const face of faces){
							const pa = project(face[0]);
							const pb = project(face[1]);
							const pc = project(face[2]);
							if(!pa||!pb||!pc) continue;
							ctx.beginPath();
							ctx.moveTo(pa.x,pa.y);
							ctx.lineTo(pb.x,pb.y);
							ctx.lineTo(pc.x,pc.y);
							ctx.closePath();
							ctx.strokeStyle = (obj.color||'#ffffff');
							ctx.lineWidth = 1;
							ctx.stroke();
						}
					}
				}
			}

			// project all object centers for picking/rendering
			const projected = objects.map(o=>({o,p:project(o)})).filter(x=>x.p);
			projected.sort((a,b)=>b.p.z - a.p.z);

			for(const item of projected){
				const o = item.o, p = item.p;
				const size = 56 * p.scale; // base size scaled by depth
				ctx.save();
				ctx.translate(p.x, p.y);
				// simple shaded quad representing object center
				const shade = Math.max(0.2, Math.min(1, 1 - (p.z/2000)));
				ctx.fillStyle = shadeColor(o.color||'#06b6d4', shade);
				roundedRect(ctx, -size/2, -size/2, size, size, Math.max(4, size*0.12));
				ctx.fill();
				ctx.fillStyle = '#042028';
				ctx.font = `${Math.max(10, 12 * p.scale)}px sans-serif`;
				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';
				ctx.fillText(o.name[0] || '?', 0, 0);
				if(selectedId === o.id){
					ctx.lineWidth = 2;
					ctx.strokeStyle = 'rgba(255,255,255,0.9)';
					ctx.stroke();
				}
				ctx.restore();
			}
		}

		// helper: rounded rectangle path
		function roundedRect(ctx,x,y,w,h,r){
			const radius = r;
			ctx.beginPath();
			ctx.moveTo(x+radius,y);
			ctx.arcTo(x+w,y,x+w,y+h,radius);
			ctx.arcTo(x+w,y+h,x,y+h,radius);
			ctx.arcTo(x,y+h,x,y,radius);
			ctx.arcTo(x,y,x+w,y,radius);
			ctx.closePath();
		}

		// helper: shade a hex color by factor (0..1)
		function shadeColor(hex, factor){
			const c = hex.replace('#','');
			const num = parseInt(c,16);
			let r = (num >> 16) & 0xff;
			let g = (num >> 8) & 0xff;
			let b = num & 0xff;
			r = Math.round(r * factor); g = Math.round(g * factor); b = Math.round(b * factor);
			return `rgb(${r},${g},${b})`;
		}

		// handle click selection by projecting objects and checking hitboxes
		canvas.addEventListener('click', (ev)=>{
			const rect = canvas.getBoundingClientRect();
			const x = (ev.clientX - rect.left);
			const y = (ev.clientY - rect.top);
			// pick nearest object whose projected bbox contains the point
			const hits = [];
			for(const o of objects){
				const p = project(o);
				if(!p) continue;
				const size = 56 * p.scale;
				if(x >= p.x - size/2 && x <= p.x + size/2 && y >= p.y - size/2 && y <= p.y + size/2){
					hits.push({o,p});
				}
			}
			if(hits.length === 0){
				// deselect
				selectedId = null;
				selectedInfo.textContent = 'No selection';
				const ex = document.getElementById('zControl'); if(ex) ex.remove();
				refresh();
				return;
			}
			hits.sort((a,b)=>a.p.z - b.p.z); // nearest first (smaller z)
			selectObject(hits[0].o.id);
		});

		// ---------- input and physics loop ----------
		document.addEventListener('keydown',(e)=>{
			if(e.repeat) return;
			const k = e.key.toLowerCase();
			keysDown.add(k);
			// inventory toggle
			if(k === 'e'){
				inventoryOpen = !inventoryOpen;
				console.log('Inventory',inventoryOpen);
			}
			// interact
			if(k === 'q'){
				const obj = getObjectInCenter();
				if(obj){
					// default interact: add a property interactions++
					obj.interactions = (obj.interactions||0) + 1;
					console.log('Interacted with',obj.name,obj.interactions);
				}
			}
			// other object-defined keys (zxc... etc)
			const center = getObjectInCenter();
			if(center && center.actions){
				for(const a of center.actions){
					if(a.key === k){
						console.log('Action',a.name,'on',center.name);
						// custom: mark lastAction
						center.lastAction = a.name;
					}
				}
			}
		});

		document.addEventListener('keyup',(e)=>{
			keysDown.delete(e.key.toLowerCase());
		});

		let lastFrame = performance.now();

		function physicsStep(now){
			const dt = Math.max(0, Math.min(0.05, (now - lastFrame)/1000));
			lastFrame = now;

			// controls: arrows to look (adjust player rotation), WASD to move relative to player rotation
			if(keysDown.has('arrowleft')){ player.rotY = (player.rotY || 0) - 2.5 * dt; }
			if(keysDown.has('arrowright')){ player.rotY = (player.rotY || 0) + 2.5 * dt; }
			if(keysDown.has('arrowup')){ player.pitch = Math.max(-1.2,(player.pitch||0) - 2.5 * dt); }
			if(keysDown.has('arrowdown')){ player.pitch = Math.min(1.2,(player.pitch||0) + 2.5 * dt); }

			// movement vector in local space
			let mvx=0, mvz=0;
			if(keysDown.has('w')) mvz -= 1;
			if(keysDown.has('s')) mvz += 1;
			if(keysDown.has('a')) mvx -= 1;
			if(keysDown.has('d')) mvx += 1;
			const len = Math.hypot(mvx,mvz);
			if(len>0){ mvx/=len; mvz/=len; }

			// rotate movement by player.rotY
			const rot = player.rotY || 0;
			const sinR = Math.sin(rot), cosR = Math.cos(rot);
			const worldDX = mvx * cosR - mvz * sinR;
			const worldDZ = mvx * sinR + mvz * cosR;

			// desired new position (horizontal)
			const speed = player.speed;
			const desired = {x: player.x + worldDX * speed * dt, y: player.y, z: player.z + worldDZ * speed * dt};

			// check horizontal collision by testing player's origin point at desired pos against world/wall tetrahedrons
			if(!isBlockedByWorld({x:desired.x,y:desired.y,z:desired.z})){
				player.x = desired.x; player.z = desired.z;
			}

			// gravity
			const GRAV = 900; // units/s^2
			player.vel.y += GRAV * dt * 1; // downward positive
			player.y += player.vel.y * dt;
			// ground at y=0
			if(player.y >= 0){ player.y = 0; player.vel.y = 0; player.onGround = true; }
			else{ player.onGround = false; }

			// jump (space)
			if(keysDown.has(' ' ) || keysDown.has('space') ){
				if(player.onGround){ player.vel.y = -player.jumpImpulse; player.onGround = false; }
			}

			// update camera to follow in renderStage
			renderStage();
			requestAnimationFrame(physicsStep);
		}

		requestAnimationFrame(physicsStep);


		function renderList(){
			objectList.innerHTML = '';
			objects.forEach(obj=>{
				const row = document.createElement('div');
				row.className = 'object-row';
				row.dataset.id = obj.id;

				const color = document.createElement('div');
				color.className = 'object-color';
				color.style.background = obj.color;

				const meta = document.createElement('div');
				meta.innerHTML = `<div style="font-weight:700">${obj.name}</div><div class="muted">id:${obj.id} — ${Math.round(obj.x)},${Math.round(obj.y)}</div>`;

				row.appendChild(color);
				row.appendChild(meta);

				row.addEventListener('click', ()=> selectObject(obj.id));

				objectList.appendChild(row);
			});
		}

		function selectObject(id){
			selectedId = id;
			const obj = objects.find(o=>o.id === id);
			if(!obj) return;
			// update overlay info
			selectedInfo.textContent = `${obj.name} — ${obj.description}`;
			// add z control when selected
			renderSelectedZControl(obj);
			// highlight selected element in stage
			scene.querySelectorAll('.obj').forEach(el=>el.style.outline='');
			const el = scene.querySelector(`.obj[data-id='${id}']`);
			if(el) el.style.outline = `3px solid rgba(255,255,255,0.12)`;
			// ensure overlay visible
			overlay.style.display = '';
		}

		// render a Z slider for the selected object inside the overlay
		function renderSelectedZControl(obj){
			let existing = document.getElementById('zControl');
			if(existing) existing.remove();
			const wrap = document.createElement('div');
			wrap.id = 'zControl';
			wrap.style.marginTop = '8px';
			wrap.innerHTML = `
				<div style="font-size:13px;margin-bottom:6px">Depth (z): <span id="zValue">${obj.z || 0}</span>px</div>
				<input type="range" id="zRange" min="-600" max="600" step="1" value="${obj.z || 0}" />
			`;

			wrap.querySelector('#zRange').addEventListener('input', (e)=>{
				const v = Number(e.target.value);
				obj.z = v;
				wrap.querySelector('#zValue').textContent = v;
				refresh();
			});

			overlay.appendChild(wrap);
		}

		// helpers
		function addRandomObject(){
			const id = Date.now();
			const x = Math.random()*(stage.clientWidth-80)+40;
			const y = Math.random()*(stage.clientHeight-80)+40;
			const palette = ['#ef4444','#06b6d4','#f97316','#34d399','#a78bfa','#f59e0b'];
			const color = palette[Math.floor(Math.random()*palette.length)];
			const obj = {id,name:`Obj${String(id).slice(-4)}`.replace('id','Obj'),x,y,color,description:'A randomly created object'};
			// ensure name exists properly
			obj.name = 'Obj' + (objects.length+1);
			objects.push(obj);
			refresh();
			selectObject(obj.id);
		}

		function clearObjects(){
			objects = [];
			selectedId = null;
			selectedInfo.textContent = 'No selection';
			refresh();
		}

		function centerSelected(){
			if(!selectedId) return;
			const obj = objects.find(o=>o.id===selectedId);
			if(!obj) return;
			obj.x = stage.clientWidth/2;
			obj.y = stage.clientHeight/2;
			refresh();
			selectObject(obj.id);
		}

		function refresh(){
			renderStage();
			renderList();
		}

		// events
		toggleOverlayBtn.addEventListener('click', ()=>{
			overlay.style.display = overlay.style.display === 'none' ? '' : 'none';
		});
		addBtn.addEventListener('click', addRandomObject);
		clearBtn.addEventListener('click', clearObjects);
		centerBtn.addEventListener('click', centerSelected);

		// click stage to deselect
		stage.addEventListener('click', ()=>{
			selectedId = null;
			selectedInfo.textContent = 'No selection';
			stage.querySelectorAll('.obj').forEach(el=>el.style.outline='');
		});

		// initial render
		refresh();

		// responsive: re-render on resize to keep positions within bounds
		window.addEventListener('resize', ()=>{
			// clamp objects into visible area
			objects.forEach(o=>{
				o.x = Math.max(30, Math.min(stage.clientWidth-30, o.x));
				o.y = Math.max(30, Math.min(stage.clientHeight-30, o.y));
			});
			refresh();
		});
	</script>
</body>
</html>
