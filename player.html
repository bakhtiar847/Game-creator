<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Player — Objects & Overlay</title>
	<style>
		:root{--bg:#0f1721;--card:#0b1220;--accent:#06b6d4;--muted:#94a3b8}
		html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;color:#e6eef6;background:linear-gradient(180deg,#071022 0%,#071a2a 100%)}
		.container{display:flex;flex-direction:column;height:100vh}
		header{padding:12px 16px;display:flex;align-items:center;gap:12px}
		h1{font-size:18px;margin:0;color:var(--accent)}
		.toolbar{margin-left:auto;display:flex;gap:8px}
		button{background:var(--card);border:1px solid rgba(255,255,255,0.04);color:#dff7ff;padding:8px 10px;border-radius:8px;cursor:pointer}
		main{flex:1;display:flex;gap:12px;padding:12px}
		/* game area */
		.stage{flex:1;background:rgba(255,255,255,0.02);border-radius:10px;position:relative;overflow:hidden;border:1px solid rgba(255,255,255,0.03)}
		.grid{position:absolute;inset:0;background-image:linear-gradient(rgba(255,255,255,0.01) 1px, transparent 1px),linear-gradient(90deg,rgba(255,255,255,0.01) 1px, transparent 1px);background-size:40px 40px,40px 40px}
		.obj{position:absolute;width:56px;height:56px;border-radius:8px;display:flex;align-items:center;justify-content:center;color:#041826;font-weight:700;cursor:pointer;box-shadow:0 4px 12px rgba(2,6,23,0.6);transform:translate(-50%,-50%)}
		/* overlay */
		.overlay{position:fixed;right:16px;top:16px;width:320px;max-width:calc(100% - 40px);background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0.02));backdrop-filter:blur(6px);border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.04)}
		.overlay h2{margin:0 0 8px 0;font-size:15px;color:var(--accent)}
		.overlay .meta{font-size:13px;color:var(--muted);margin-bottom:8px}
		.object-list{display:flex;flex-direction:column;gap:6px;max-height:220px;overflow:auto}
		.object-row{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);cursor:pointer}
		.object-color{width:32px;height:32px;border-radius:6px;flex:0 0 32px}
		.muted{color:var(--muted);font-size:13px}
		footer{padding:8px 16px;font-size:13px;color:var(--muted)}
		@media (max-width:600px){.overlay{position:fixed;left:8px;right:8px;top:auto;bottom:8px;width:auto}}
	</style>
</head>
<body>
	<div class="container">
		<header>
			<h1>Player — Objects Preview</h1>
			<div class="toolbar">
				<button id="addBtn">Add random object</button>
				<button id="toggleOverlay">Toggle overlay</button>
			</div>
		</header>

		<main>
			<section class="stage" id="stage" aria-label="Game stage">
				<canvas id="canvas" aria-label="3D canvas renderer"></canvas>
				<div class="grid" aria-hidden="true"></div>
			</section>

			<!-- overlay: object details + list -->
			<aside class="overlay" id="overlay">
				<h2>Objects</h2>
				<div class="meta">Click an object on the stage to view details here.</div>
				<div class="object-list" id="objectList" role="list"></div>
				<div style="margin-top:8px;display:flex;gap:8px;justify-content:space-between;align-items:center">
					<div class="muted" id="selectedInfo">No selection</div>
					<div style="display:flex;gap:8px">
						<button id="centerBtn">Center selected</button>
						<button id="clearBtn">Clear objects</button>
					</div>
				</div>
			</aside>
		</main>

		<footer>
			This demo renders an objects array and shows an overlay with details. Open this file in a browser to interact.
		</footer>
	</div>

	<script>
		// Simple objects array to render. Each object has id,name,x,y,color,description
		let objects = [
			{id:1,name:'Player',x:150,y:120,z:40,color:'#06b6d4',description:'Main player character'},
			{id:2,name:'Tree',x:420,y:200,z:0,color:'#34d399',description:'A tall oak tree.'},
			{id:3,name:'Chest',x:300,y:380,z:-80,color:'#f59e0b',description:'A treasure chest with loot.'}
		];

		const stage = document.getElementById('stage');
		const canvas = document.getElementById('canvas');
		const ctx = canvas.getContext('2d');
		const objectList = document.getElementById('objectList');
		const overlay = document.getElementById('overlay');
		const toggleOverlayBtn = document.getElementById('toggleOverlay');
		const addBtn = document.getElementById('addBtn');
		const clearBtn = document.getElementById('clearBtn');
		const centerBtn = document.getElementById('centerBtn');
		const selectedInfo = document.getElementById('selectedInfo');

		let selectedId = null;

		// ---------- Canvas 3D renderer (software, from-scratch) ----------
		function resizeCanvas(){
			const dpr = window.devicePixelRatio || 1;
			canvas.width = Math.max(300, stage.clientWidth) * dpr;
			canvas.height = Math.max(150, stage.clientHeight) * dpr;
			canvas.style.width = stage.clientWidth + 'px';
			canvas.style.height = stage.clientHeight + 'px';
			ctx.setTransform(dpr,0,0,dpr,0,0);
		}

		const Camera = function(){
			this.x = 0; this.y = 0; this.z = -700; // camera placed behind origin
			this.rotX = 0; this.rotY = 0; // radians
			this.fov = 60; // degrees
			this.focal = 1 / Math.tan((this.fov/2) * Math.PI/180) * 500; // rough focal length
		}

		Camera.prototype.updateFocal = function(){
			this.focal = 1 / Math.tan((this.fov/2) * Math.PI/180) * 500;
		}

		const camera = new Camera();

		function project(obj){
			// world coords (x,y,z) -> camera coords -> rotate -> perspective -> screen
			const cx = canvas.width/2 / (window.devicePixelRatio||1);
			const cy = canvas.height/2 / (window.devicePixelRatio||1);

			// translate relative to camera
			let x = obj.x - cx;
			let y = obj.y - cy;
			let z = obj.z - camera.z;

			// rotate Y (around vertical axis)
			const cosY = Math.cos(camera.rotY), sinY = Math.sin(camera.rotY);
			let rx = x * cosY - z * sinY;
			let rz = x * sinY + z * cosY;

			// rotate X
			const cosX = Math.cos(camera.rotX), sinX = Math.sin(camera.rotX);
			let ry = y * cosX - rz * sinX;
			rlz = y * sinX + rz * cosX;

			// if behind camera, mark as culled
			if(rlz <= 5) return null;

			const scale = camera.focal / rlz;
			return {
				x: cx + rx * scale,
				y: cy + ry * scale,
				scale: scale,
				z: rlz
			};
		}

		function renderStage(){
			resizeCanvas();
			ctx.clearRect(0,0,canvas.width,canvas.height);

			// project all objects and sort by depth (draw far first)
			const projected = objects.map(o=>({o,p:project(o)})).filter(x=>x.p);
			projected.sort((a,b)=>b.p.z - a.p.z);

			for(const item of projected){
				const o = item.o, p = item.p;
				const size = 56 * p.scale; // base size scaled by depth
				ctx.save();
				ctx.translate(p.x, p.y);
				// shadow / simple shading based on depth
				const shade = Math.max(0.2, Math.min(1, 1 - (p.z/2000)));
				ctx.fillStyle = shadeColor(o.color, shade);
				roundedRect(ctx, -size/2, -size/2, size, size, Math.max(4, size*0.12));
				ctx.fill();
				// label
				ctx.fillStyle = '#042028';
				ctx.font = `${Math.max(10, 12 * p.scale)}px sans-serif`;
				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';
				ctx.fillText(o.name[0] || '?', 0, 0);
				// outline for selected
				if(selectedId === o.id){
					ctx.lineWidth = 2;
					ctx.strokeStyle = 'rgba(255,255,255,0.9)';
					ctx.stroke();
				}
				ctx.restore();
			}
		}

		// helper: rounded rectangle path
		function roundedRect(ctx,x,y,w,h,r){
			const radius = r;
			ctx.beginPath();
			ctx.moveTo(x+radius,y);
			ctx.arcTo(x+w,y,x+w,y+h,radius);
			ctx.arcTo(x+w,y+h,x,y+h,radius);
			ctx.arcTo(x,y+h,x,y,radius);
			ctx.arcTo(x,y,x+w,y,radius);
			ctx.closePath();
		}

		// helper: shade a hex color by factor (0..1)
		function shadeColor(hex, factor){
			const c = hex.replace('#','');
			const num = parseInt(c,16);
			let r = (num >> 16) & 0xff;
			let g = (num >> 8) & 0xff;
			let b = num & 0xff;
			r = Math.round(r * factor); g = Math.round(g * factor); b = Math.round(b * factor);
			return `rgb(${r},${g},${b})`;
		}

		// handle click selection by projecting objects and checking hitboxes
		canvas.addEventListener('click', (ev)=>{
			const rect = canvas.getBoundingClientRect();
			const x = (ev.clientX - rect.left);
			const y = (ev.clientY - rect.top);
			// pick nearest object whose projected bbox contains the point
			const hits = [];
			for(const o of objects){
				const p = project(o);
				if(!p) continue;
				const size = 56 * p.scale;
				if(x >= p.x - size/2 && x <= p.x + size/2 && y >= p.y - size/2 && y <= p.y + size/2){
					hits.push({o,p});
				}
			}
			if(hits.length === 0){
				// deselect
				selectedId = null;
				selectedInfo.textContent = 'No selection';
				const ex = document.getElementById('zControl'); if(ex) ex.remove();
				refresh();
				return;
			}
			hits.sort((a,b)=>a.p.z - b.p.z); // nearest first (smaller z)
			selectObject(hits[0].o.id);
		});


		function renderList(){
			objectList.innerHTML = '';
			objects.forEach(obj=>{
				const row = document.createElement('div');
				row.className = 'object-row';
				row.dataset.id = obj.id;

				const color = document.createElement('div');
				color.className = 'object-color';
				color.style.background = obj.color;

				const meta = document.createElement('div');
				meta.innerHTML = `<div style="font-weight:700">${obj.name}</div><div class="muted">id:${obj.id} — ${Math.round(obj.x)},${Math.round(obj.y)}</div>`;

				row.appendChild(color);
				row.appendChild(meta);

				row.addEventListener('click', ()=> selectObject(obj.id));

				objectList.appendChild(row);
			});
		}

		function selectObject(id){
			selectedId = id;
			const obj = objects.find(o=>o.id === id);
			if(!obj) return;
			// update overlay info
			selectedInfo.textContent = `${obj.name} — ${obj.description}`;
			// add z control when selected
			renderSelectedZControl(obj);
			// highlight selected element in stage
			scene.querySelectorAll('.obj').forEach(el=>el.style.outline='');
			const el = scene.querySelector(`.obj[data-id='${id}']`);
			if(el) el.style.outline = `3px solid rgba(255,255,255,0.12)`;
			// ensure overlay visible
			overlay.style.display = '';
		}

		// render a Z slider for the selected object inside the overlay
		function renderSelectedZControl(obj){
			let existing = document.getElementById('zControl');
			if(existing) existing.remove();
			const wrap = document.createElement('div');
			wrap.id = 'zControl';
			wrap.style.marginTop = '8px';
			wrap.innerHTML = `
				<div style="font-size:13px;margin-bottom:6px">Depth (z): <span id="zValue">${obj.z || 0}</span>px</div>
				<input type="range" id="zRange" min="-600" max="600" step="1" value="${obj.z || 0}" />
			`;

			wrap.querySelector('#zRange').addEventListener('input', (e)=>{
				const v = Number(e.target.value);
				obj.z = v;
				wrap.querySelector('#zValue').textContent = v;
				refresh();
			});

			overlay.appendChild(wrap);
		}

		// helpers
		function addRandomObject(){
			const id = Date.now();
			const x = Math.random()*(stage.clientWidth-80)+40;
			const y = Math.random()*(stage.clientHeight-80)+40;
			const palette = ['#ef4444','#06b6d4','#f97316','#34d399','#a78bfa','#f59e0b'];
			const color = palette[Math.floor(Math.random()*palette.length)];
			const obj = {id,name:`Obj${String(id).slice(-4)}`.replace('id','Obj'),x,y,color,description:'A randomly created object'};
			// ensure name exists properly
			obj.name = 'Obj' + (objects.length+1);
			objects.push(obj);
			refresh();
			selectObject(obj.id);
		}

		function clearObjects(){
			objects = [];
			selectedId = null;
			selectedInfo.textContent = 'No selection';
			refresh();
		}

		function centerSelected(){
			if(!selectedId) return;
			const obj = objects.find(o=>o.id===selectedId);
			if(!obj) return;
			obj.x = stage.clientWidth/2;
			obj.y = stage.clientHeight/2;
			refresh();
			selectObject(obj.id);
		}

		function refresh(){
			renderStage();
			renderList();
		}

		// events
		toggleOverlayBtn.addEventListener('click', ()=>{
			overlay.style.display = overlay.style.display === 'none' ? '' : 'none';
		});
		addBtn.addEventListener('click', addRandomObject);
		clearBtn.addEventListener('click', clearObjects);
		centerBtn.addEventListener('click', centerSelected);

		// click stage to deselect
		stage.addEventListener('click', ()=>{
			selectedId = null;
			selectedInfo.textContent = 'No selection';
			stage.querySelectorAll('.obj').forEach(el=>el.style.outline='');
		});

		// initial render
		refresh();

		// responsive: re-render on resize to keep positions within bounds
		window.addEventListener('resize', ()=>{
			// clamp objects into visible area
			objects.forEach(o=>{
				o.x = Math.max(30, Math.min(stage.clientWidth-30, o.x));
				o.y = Math.max(30, Math.min(stage.clientHeight-30, o.y));
			});
			refresh();
		});
	</script>
</body>
</html>
