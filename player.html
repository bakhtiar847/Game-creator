<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Player — Objects & Overlay</title>
	<style>
		:root{--bg:#0f1721;--card:#0b1220;--accent:#06b6d4;--muted:#94a3b8}
	html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;color:#e6eef6;background:linear-gradient(180deg,#071022 0%,#071a2a 100%);overflow:hidden}
	.container{display:flex;flex-direction:column;height:100vh;overflow:hidden}
		header{padding:12px 16px;display:flex;align-items:center;gap:12px}
		h1{font-size:18px;margin:0;color:var(--accent)}
		.toolbar{margin-left:auto;display:flex;gap:8px}
		button{background:var(--card);border:1px solid rgba(255,255,255,0.04);color:#dff7ff;padding:8px 10px;border-radius:8px;cursor:pointer}
	main{flex:1;display:flex;gap:12px;padding:12px;min-height:0;box-sizing:border-box}
		/* game area */
	.stage{flex:1;background:rgba(255,255,255,0.02);border-radius:10px;position:relative;overflow:hidden;border:1px solid rgba(255,255,255,0.03)}
	/* canvas should fill the stage without causing scrollbars */
	#canvas{position:absolute;left:0;top:0;width:100%;height:100%;display:block}
		.grid{position:absolute;inset:0;background-image:linear-gradient(rgba(255,255,255,0.01) 1px, transparent 1px),linear-gradient(90deg,rgba(255,255,255,0.01) 1px, transparent 1px);background-size:40px 40px,40px 40px}
		.obj{position:absolute;width:56px;height:56px;border-radius:8px;display:flex;align-items:center;justify-content:center;color:#041826;font-weight:700;cursor:pointer;box-shadow:0 4px 12px rgba(2,6,23,0.6);transform:translate(-50%,-50%)}
		/* overlay */
		.overlay{position:fixed;right:16px;top:16px;width:320px;max-width:calc(100% - 40px);background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0.02));backdrop-filter:blur(6px);border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.04)}
		.overlay h2{margin:0 0 8px 0;font-size:15px;color:var(--accent)}
		.overlay .meta{font-size:13px;color:var(--muted);margin-bottom:8px}
		.object-list{display:flex;flex-direction:column;gap:6px;max-height:220px;overflow:auto}
		.object-row{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);cursor:pointer}
		.object-color{width:32px;height:32px;border-radius:6px;flex:0 0 32px}
		.muted{color:var(--muted);font-size:13px}
		footer{padding:8px 16px;font-size:13px;color:var(--muted)}
		@media (max-width:600px){.overlay{position:fixed;left:8px;right:8px;top:auto;bottom:8px;width:auto}}
	</style>
</head>
<body>
	<div class="container">
		<header>
			<h1>Player — Objects Preview</h1>
			<div class="toolbar"></div>
		</header>

		<main>
			<section class="stage" id="stage" aria-label="Game stage">
				<canvas id="canvas" aria-label="3D canvas renderer"></canvas>
				<div class="grid" aria-hidden="true"></div>
			</section>
		</main>

		<!-- overlay panel -->
		<div class="overlay" id="overlay">
			<h2>Objects</h2>
			<div class="meta">Scene objects and quick actions</div>
			<div style="display:flex;gap:8px;margin-bottom:8px">
				<button id="addBtn">Add random object</button>
				<button id="clearBtn">Clear objects</button>
				<button id="centerBtn">Center selected</button>
				<button id="toggleOverlay">Toggle</button>
			</div>
			<div class="object-list" id="objectList" style="margin-bottom:8px"></div>
			<div id="selectedInfo" class="muted">No selection</div>
		</div>

		<footer>
			This demo renders an objects array and shows an overlay with details. Open this file in a browser to interact.
		</footer>
	</div>

	<script>
		// Objects now have richer structure:
		// { id, name, x,y,z (origin), triangles: [{p1:{x,y,z}, p2, p3}], tetrahedrons: [{a,b,c,d}], actions: [{key,name}], flags: isplayer,isworld,iswall }
		let objects = [
			// green floor object (large area under ground)
			{
				id:4,
				name:'Floor',
				x:0,y:-45,z:0,
				triangles:[],
				tetrahedrons:[
					{a:{x:-2000,y:-50,z:-2000},b:{x:2000,y:-50,z:-2000},c:{x:2000,y:-50,z:2000},d:{x:-2000,y:-40,z:2000}}
				],
				actions:[],
				isworld:true,
				iswall:true,
				color:'#16a34a',
				description:'Green floor object'
			},
			{
				id:1,
				name:'Player',
				x:300,y:100,z:200,
				triangles:[],
				tetrahedrons:[],
				actions:[],
				isplayer:true
			},
			{
				id:2,
				name:'Wall',
				x:500,y:0,z:400,
				triangles:[],
				// simple tetrahedron (four points) in world coords
				tetrahedrons:[
					{a:{x:480,y:0,z:380},b:{x:520,y:0,z:380},c:{x:520,y:100,z:420},d:{x:480,y:100,z:420}}
				],
				actions:[{key:'q',name:'inspect'}],
				isworld:true,
				iswall:true,
				color:'#94a3b8',
				description:'A simple wall tetrahedron'
			},
			{
				id:3,
				name:'Chest',
				x:300,y:0,z:500,
				triangles:[],
				tetrahedrons:[{a:{x:280,y:0,z:480},b:{x:320,y:0,z:480},c:{x:320,y:60,z:520},d:{x:280,y:60,z:520}}],
				actions:[{key:'q',name:'open'}, {key:'z',name:'special'}],
				isworld:false,
				iswall:false,
				color:'#f59e0b',
				description:'A treasure chest with loot.'
			}
		];

		// Texture loader: attach an Image to object.texture when textureSrc is present
		function loadTexture(obj, src){
			const img = new Image();
			img.crossOrigin = 'anonymous';
			img.onload = ()=>{ obj.texture = img; renderer && renderer.render(); };
			img.onerror = ()=>{ console.warn('Failed to load texture', src); };
			img.src = src;
			return img;
		}

		// auto-load textures if objects specify textureSrc
		for(const o of objects){ if(o.textureSrc) loadTexture(o, o.textureSrc); }

		// --- Chest mesh builder (rectangular prism + curved lid template) ---
		function buildChestMesh(obj){
			// dimensions
			const w = 80, h = 40, d = 60; // width(x), height(y), depth(z)
			const hw = w/2, hd = d/2;
			// base corners (local coords)
			const v = {
				p000: {x:-hw,y:0,z:-hd}, p100:{x:hw,y:0,z:-hd}, p010:{x:-hw,y:h,z:-hd}, p110:{x:hw,y:h,z:-hd},
				p001:{x:-hw,y:0,z:hd}, p101:{x:hw,y:0,z:hd}, p011:{x:-hw,y:h,z:hd}, p111:{x:hw,y:h,z:hd}
			};
			// base triangles (omit top face, lid will cover)
			const tris = [];
			function t(a,b,c){ tris.push([a,b,c]); }
			// front face (z = hd)
			t(v.p001,v.p101,v.p111); t(v.p001,v.p111,v.p011);
			// back face (z = -hd)
			t(v.p100,v.p000,v.p010); t(v.p100,v.p010,v.p110);
			// left face (x = -hw)
			t(v.p000,v.p001,v.p011); t(v.p000,v.p011,v.p010);
			// right face (x = hw)
			t(v.p101,v.p100,v.p110); t(v.p101,v.p110,v.p111);
			// bottom face
			t(v.p000,v.p100,v.p101); t(v.p000,v.p101,v.p001);

			// lid template: approximate curved lid along width with segments
			const segments = 9;
			const lid = {verts:[], indices:[]};
			for(let i=0;i<segments;i++){
				const tNorm = i/(segments-1);
				const x = -hw + tNorm * w;
				// semicircular arc in local Y above top h
				const arc = Math.sin(Math.PI * tNorm) * 20; // lid bulge
				// back point (z = -hd) and front point (z = hd)
				lid.verts.push({x:x,y:h+arc,z:-hd}); // back
				lid.verts.push({x:x,y:h+arc,z:hd});  // front
			}
			// indices (quads between segments -> two tris)
			for(let i=0;i<segments-1;i++){
				const a = i*2, b = i*2+1, c = (i+1)*2, d = (i+1)*2+1;
				// two triangles: back(i)->front(i)->front(i+1) and back(i)->front(i+1)->back(i+1)
				lid.indices.push([lid.verts[a], lid.verts[b], lid.verts[d]]);
				lid.indices.push([lid.verts[a], lid.verts[d], lid.verts[c]]);
			}

			obj._baseTris = tris; // array of [a,b,c] where a,b,c are vertex objects with local coords
			obj._lidTemplate = lid; // contains verts (local) and indices (triples of vertex objects)
			obj._chestDims = {w,h,d,hw,hd};
			// state
			obj.opened = obj.opened || false;
			obj.lidAngle = obj.lidAngle || 0; // radians, 0 closed
			obj.lidTarget = obj.lidTarget || 0; // target angle
		}

		// build chest mesh for existing chest objects
		for(const o of objects){ if(o.name && o.name.toLowerCase() === 'chest') buildChestMesh(o); }

		// find player reference and set up player physics state
		let player = objects.find(o=>o.isplayer);
		if(!player){
			player = {id:0,name:'Player',x:300,y:100,z:200,triangles:[],tetrahedrons:[],actions:[],isplayer:true};
			objects.unshift(player);
		}
		player.vel = {x:0,y:0,z:0};
		player.speed = 120; // units per second
		player.radius = 28; // collision radius in world units
		player.jumpImpulse = 320;
		player.onGround = false;

		// input state
		const keysDown = new Set();

		// simple inventory
		let inventoryOpen = false;


		const stage = document.getElementById('stage');
		const canvas = document.getElementById('canvas');
		const ctx = canvas.getContext('2d');
		const objectList = document.getElementById('objectList');
		const overlay = document.getElementById('overlay');
		const toggleOverlayBtn = document.getElementById('toggleOverlay');
		const addBtn = document.getElementById('addBtn');
		const clearBtn = document.getElementById('clearBtn');
		const centerBtn = document.getElementById('centerBtn');
		const selectedInfo = document.getElementById('selectedInfo');

		let selectedId = null;

		// (renderer will handle canvas resizing and drawing)

		const Camera = function(){
			this.x = 0; this.y = 0; this.z = -700; // camera placed behind origin
			this.rotX = 0; this.rotY = 0; // radians
			this.fov = 60; // degrees
			this.focal = 1 / Math.tan((this.fov/2) * Math.PI/180) * 500; // rough focal length
		}

		Camera.prototype.updateFocal = function(){
			this.focal = 1 / Math.tan((this.fov/2) * Math.PI/180) * 500;
		}

		const camera = new Camera();

		// ---------- Renderer: encapsulates canvas-based 3D rendering ----------
		class Renderer {
			constructor(canvas, ctx, camera, objects, player){
				this.canvas = canvas; this.ctx = ctx; this.camera = camera; this.objects = objects; this.player = player;
				this.dpr = window.devicePixelRatio || 1;
			}

			resize(){
				this.dpr = window.devicePixelRatio || 1;
				this.canvas.width = Math.max(300, stage.clientWidth) * this.dpr;
				this.canvas.height = Math.max(150, stage.clientHeight) * this.dpr;
				this.canvas.style.width = stage.clientWidth + 'px';
				this.canvas.style.height = stage.clientHeight + 'px';
				this.ctx.setTransform(this.dpr,0,0,this.dpr,0,0);
			}

			projectPoint(pt){
				const cx = this.canvas.width/2 / (window.devicePixelRatio||1);
				const cy = this.canvas.height/2 / (window.devicePixelRatio||1);
				let x = pt.x - this.camera.x;
				let y = pt.y - this.camera.y;
				let z = pt.z - this.camera.z;

				const cosY = Math.cos(this.camera.rotY), sinY = Math.sin(this.camera.rotY);
				let rx = x * cosY - z * sinY;
				let rz = x * sinY + z * cosY;

				const cosX = Math.cos(this.camera.rotX), sinX = Math.sin(this.camera.rotX);
				let ry = y * cosX - rz * sinX;
				let rlz = y * sinX + rz * cosX;

				if(rlz <= 5) return null;
				const scale = this.camera.focal / rlz;
				return {x: cx + rx * scale, y: cy + ry * scale, scale: scale, z: rlz};
			}

			// draw a floor grid at y=0
			drawFloor(){
				const ctx = this.ctx;
				ctx.save();
				ctx.lineWidth = 1;
				ctx.strokeStyle = 'rgba(255,255,255,0.04)';
				// grid spacing and extents
				const spacing = 100;
				const extent = 2000;
				for(let z = -extent; z<=extent; z+=spacing){
					const a = this.projectPoint({x:-extent,y:0,z:z});
					const b = this.projectPoint({x:extent,y:0,z:z});
					if(a && b){ ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); }
				}
				for(let x = -extent; x<=extent; x+=spacing){
					const a = this.projectPoint({x:x,y:0,z:-extent});
					const b = this.projectPoint({x:x,y:0,z:extent});
					if(a && b){ ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); }
				}
				ctx.restore();
			}

			drawTetrahedrons(){
				const ctx = this.ctx;
				for(const obj of this.objects){
					if(!obj.tetrahedrons) continue;
					for(const tet of obj.tetrahedrons){
						const faces = [[tet.a,tet.b,tet.c],[tet.a,tet.b,tet.d],[tet.a,tet.c,tet.d],[tet.b,tet.c,tet.d]];
						for(const face of faces){
									const pa = this.projectPoint(face[0]);
									const pb = this.projectPoint(face[1]);
									const pc = this.projectPoint(face[2]);
									if(!pa||!pb||!pc) continue;
									ctx.beginPath(); ctx.moveTo(pa.x,pa.y); ctx.lineTo(pb.x,pb.y); ctx.lineTo(pc.x,pc.y); ctx.closePath();
									// fill face with slight transparency for volume perception
									ctx.fillStyle = hexToRgba(obj.color||'#888', 0.08);
									ctx.fill();
									ctx.strokeStyle = (obj.color||'#888'); ctx.lineWidth = 1; ctx.stroke();
						}
					}
				}
			}

			// draw arbitrary triangles from object meshes (triangles are provided in world coords)
			drawTriangles(){
				const ctx = this.ctx;
				const renderList = [];
				for(const obj of this.objects){
					if(!obj._renderTris) continue;
					for(const tri of obj._renderTris){
						// compute average depth for sorting
						const pa = this.projectPoint(tri[0]);
						const pb = this.projectPoint(tri[1]);
						const pc = this.projectPoint(tri[2]);
						if(!pa||!pb||!pc) continue;
						renderList.push({obj, tri, pa, pb, pc, depth:(pa.z+pb.z+pc.z)/3});
					}
				}
				renderList.sort((a,b)=>b.depth - a.depth);
				for(const it of renderList){
					const obj = it.obj; const pa = it.pa, pb = it.pb, pc = it.pc;
					ctx.beginPath(); ctx.moveTo(pa.x,pa.y); ctx.lineTo(pb.x,pb.y); ctx.lineTo(pc.x,pc.y); ctx.closePath();
					ctx.fillStyle = hexToRgba(obj.color||'#888', 0.95);
					ctx.fill(); ctx.strokeStyle = shadeColor(obj.color||'#444', 0.9); ctx.lineWidth=1; ctx.stroke();
				}
			}

			drawObjects(){
				const ctx = this.ctx;
				const projected = this.objects.map(o=>({o,p:this.projectPoint(o)})).filter(x=>x.p);
				projected.sort((a,b)=>b.p.z - a.p.z);
				for(const item of projected){
					const o = item.o, p = item.p; const size = 56 * p.scale;
					ctx.save(); ctx.translate(p.x,p.y);
					// draw either texture (if available) or circle placeholder
					if(o.texture && o.texture.complete){
						const img = o.texture;
						const aspect = img.width / img.height || 1;
						const h = Math.max(8, size);
						const w = Math.max(8, h * aspect);
						ctx.drawImage(img, -w/2, -h/2, w, h);
					} else {
						const shade = Math.max(0.2, Math.min(1, 1 - (p.z/2000)));
						ctx.fillStyle = shadeColor(o.color||'#06b6d4', shade);
						ctx.beginPath(); ctx.arc(0,0,Math.max(6,size/2),0,Math.PI*2); ctx.fill();
						ctx.fillStyle = '#042028'; ctx.font = `${Math.max(10, 12 * p.scale)}px sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
						ctx.fillText(o.name[0]||'?',0,0);
					}
					if(selectedId === o.id){ ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.stroke(); }
					ctx.restore();
				}
			}

			render(){
				this.resize(); this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
				// update camera: place inside top-center-front of player (eye position)
				const eyeHeight = 40; // above player origin
				const forwardOffset = 30; // in front of player
				const rot = this.player.rotY || 0;
				this.camera.x = this.player.x + Math.sin(rot) * forwardOffset;
				this.camera.z = this.player.z + Math.cos(rot) * forwardOffset;
				this.camera.y = this.player.y + eyeHeight;
				// camera orientation follows player view
				this.camera.rotY = this.player.rotY || 0;
				this.camera.rotX = this.player.pitch || 0;
				this.drawFloor(); this.drawTetrahedrons();
				// update per-object render triangles (e.g., chest lid transform)
				for(const obj of this.objects){
					if(obj._baseTris){
						// build world-space triangles array
						obj._renderTris = [];
						// base (translate local corners to world)
						for(const t of obj._baseTris){
							const a = {x: obj.x + t[0].x, y: obj.y + t[0].y, z: obj.z + t[0].z};
							const b = {x: obj.x + t[1].x, y: obj.y + t[1].y, z: obj.z + t[1].z};
							const c = {x: obj.x + t[2].x, y: obj.y + t[2].y, z: obj.z + t[2].z};
							obj._renderTris.push([a,b,c]);
						}
						// lid: rotate verts around hinge (back top edge)
						if(obj._lidTemplate){
							const lid = obj._lidTemplate; const dims = obj._chestDims;
							const hingeY = dims.h; const hingeZ = -dims.hd; // local hinge
							const angle = obj.lidAngle || 0;
							// precompute rotated verts
							const rotated = [];
							for(const lv of lid.verts){
								// rotate point (lv.x, lv.y, lv.z) about axis along x through (y=hingeY, z=hingeZ)
								const dx = lv.x;
								const dy = lv.y - hingeY;
								const dz = lv.z - hingeZ;
								const cosy = Math.cos(angle), siny = Math.sin(angle);
								// rotation around local X axis
								const ry = hingeY + (cosy * dy - siny * dz);
								const rz = hingeZ + (siny * dy + cosy * dz);
								rotated.push({x: dx, y: ry, z: rz});
							}
							// build triangles from indices using rotated verts
							for(const tri of lid.indices){
								// tri entries are vertex objects; need to find index by matching reference - easier: compute using consistent ordering
								// compute base index by locating tri[0] within lid.verts sequence
								const i0 = lid.verts.indexOf(tri[0]);
								const i1 = lid.verts.indexOf(tri[1]);
								const i2 = lid.verts.indexOf(tri[2]);
								if(i0<0||i1<0||i2<0) continue;
								const a = {x: obj.x + rotated[i0].x, y: obj.y + rotated[i0].y, z: obj.z + rotated[i0].z};
								const b = {x: obj.x + rotated[i1].x, y: obj.y + rotated[i1].y, z: obj.z + rotated[i1].z};
								const c = {x: obj.x + rotated[i2].x, y: obj.y + rotated[i2].y, z: obj.z + rotated[i2].z};
								obj._renderTris.push([a,b,c]);
							}
						}
					}
				}
				this.drawTriangles();
				this.drawObjects();

				// draw crosshair at center
				const cx = this.canvas.width/2 / (window.devicePixelRatio||1);
				const cy = this.canvas.height/2 / (window.devicePixelRatio||1);
				const ctx = this.ctx;
				ctx.save();
				ctx.strokeStyle = 'rgba(255,255,255,0.9)'; ctx.lineWidth = 1.5;
				ctx.beginPath(); ctx.moveTo(cx-10,cy); ctx.lineTo(cx+10,cy); ctx.moveTo(cx,cy-10); ctx.lineTo(cx,cy+10); ctx.stroke();
				ctx.restore();

				// show interact hint if chest is at center
				const centerObj = this.getObjectInCenter();
				if(centerObj && centerObj.name && centerObj.name.toLowerCase() === 'chest'){
					// project object's origin
					const p = this.projectPoint(centerObj);
					if(p){
						ctx.save();
						ctx.font = '14px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline='bottom';
						const text = centerObj.opened ? 'Chest opened' : 'Press Q to open';
						// draw bubble
						const padding = 8; const metrics = ctx.measureText(text); const tw = metrics.width + padding*2; const th = 28;
						ctx.fillStyle = 'rgba(2,6,23,0.7)'; ctx.strokeStyle = 'rgba(255,255,255,0.06)';
						// bubble centered above chest projection
						ctx.fillRect(p.x - tw/2, p.y - 48 - th, tw, th);
						ctx.fillStyle = '#e6eef6'; ctx.fillText(text, p.x, p.y - 48 - th/2 + 4);
						ctx.restore();
					}
				}
			}

			getObjectAtScreen(x,y){
				const hits = [];
				for(const o of this.objects){
					const p = this.projectPoint(o); if(!p) continue; const size = 56 * p.scale;
					if(x >= p.x - size/2 && x <= p.x + size/2 && y >= p.y - size/2 && y <= p.y + size/2) hits.push({o,p});
				}
				hits.sort((a,b)=>a.p.z - b.p.z); return hits.length?hits[0].o:null;
			}

			getObjectInCenter(){
				const rect = this.canvas.getBoundingClientRect(); const cx = rect.width/2; const cy = rect.height/2;
				return this.getObjectAtScreen(cx,cy);
			}
		}

		const renderer = new Renderer(canvas, ctx, camera, objects, player);
		// project function is provided by renderer

		// ---------- collision helpers ----------
		// signed volume of tetrahedron (a,b,c,d)
		function signedTetraVolume(a,b,c,d){
			const ax = a.x-d.x, ay = a.y-d.y, az = a.z-d.z;
			const bx = b.x-d.x, by = b.y-d.y, bz = b.z-d.z;
			const cx = c.x-d.x, cy = c.y-d.y, cz = c.z-d.z;
			return (ax * (by*cz - bz*cy) - ay * (bx*cz - bz*cx) + az * (bx*cy - by*cx)) / 6;
		}

		// compute squared distance from point p to triangle (a,b,c)
		function pointToTriangleDist2(p,a,b,c){
			// from Real-Time Collision Detection: find closest point on triangle to p
			const abx = b.x - a.x, aby = b.y - a.y, abz = b.z - a.z;
			const acx = c.x - a.x, acy = c.y - a.y, acz = c.z - a.z;
			const apx = p.x - a.x, apy = p.y - a.y, apz = p.z - a.z;

			const d1 = abx*apx + aby*apy + abz*apz;
			const d2 = acx*apx + acy*apy + acz*apz;
			if(d1 <= 0 && d2 <= 0) return apx*apx + apy*apy + apz*apz; // barycentric (1,0,0)

			const bpx = p.x - b.x, bpy = p.y - b.y, bpz = p.z - b.z;
			const d3 = abx*bpx + aby*bpy + abz*bpz;
			const d4 = acx*bpx + acy*bpy + acz*bpz;
			if(d3 >= 0 && d4 <= d3) return bpx*bpx + bpy*bpy + bpz*bpz; // barycentric (0,1,0)

			const vc = d1*d4 - d3*d2;
			if(vc <= 0 && d1 >= 0 && d3 <= 0){
				const v = d1 / (d1 - d3);
				const projx = a.x + v * abx, projy = a.y + v * aby, projz = a.z + v * abz;
				const dx = p.x - projx, dy = p.y - projy, dz = p.z - projz;
				return dx*dx + dy*dy + dz*dz;
			}

			const cpx = p.x - c.x, cpy = p.y - c.y, cpz = p.z - c.z;
			const d5 = abx*cpx + aby*cpy + abz*cpz;
			const d6 = acx*cpx + acy*cpy + acz*cpz;
			if(d6 >= 0 && d5 <= d6) return cpx*cpx + cpy*cpy + cpz*cpz; // barycentric (0,0,1)

			const vb = d5*d2 - d1*d6;
			if(vb <= 0 && d2 >= 0 && d6 <= 0){
				const w = d2 / (d2 - d6);
				const projx = a.x + w * acx, projy = a.y + w * acy, projz = a.z + w * acz;
				const dx = p.x - projx, dy = p.y - projy, dz = p.z - projz;
				return dx*dx + dy*dy + dz*dz;
			}

			const va = d3*d6 - d5*d4;
			if(va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0){
				const bcx = c.x - b.x, bcy = c.y - b.y, bcz = c.z - b.z;
				const d43 = d4 - d3, d56 = d5 - d6;
				const w = d43 / (d43 + d56);
				const projx = b.x + w * bcx, projy = b.y + w * bcy, projz = b.z + w * bcz;
				const dx = p.x - projx, dy = p.y - projy, dz = p.z - projz;
				return dx*dx + dy*dy + dz*dz;
			}

			// inside face region. compute distance to plane
			const normalX = aby*acz - abz*acy;
			const normalY = abz*acx - abx*acz;
			const normalZ = abx*acy - aby*acx;
			const nlen2 = normalX*normalX + normalY*normalY + normalZ*normalZ;
			if(nlen2 === 0) return apx*apx + apy*apy + apz*apz;
			const dist = (apx*normalX + apy*normalY + apz*normalZ) / Math.sqrt(nlen2);
			return dist*dist;
		}

		function sphereIntersectsTetra(center, radius, tet){
			// if center inside tetra -> intersect
			if(pointInTetra(center, tet)) return true;
			const r2 = radius*radius;
			// check distance to each triangular face
			const faces = [[tet.a,tet.b,tet.c],[tet.a,tet.b,tet.d],[tet.a,tet.c,tet.d],[tet.b,tet.c,tet.d]];
			for(const f of faces){
				const d2 = pointToTriangleDist2(center, f[0], f[1], f[2]);
				if(d2 <= r2 + 1e-6) return true;
			}
			return false;
		}

		function pointInTetra(pt, tet){
			// using barycentric volumes: point is inside if all sub-volumes have same sign and sum equals vol
			const v = signedTetraVolume(tet.a,tet.b,tet.c,tet.d);
			const v0 = signedTetraVolume(pt,tet.b,tet.c,tet.d);
			const v1 = signedTetraVolume(tet.a,pt,tet.c,tet.d);
			const v2 = signedTetraVolume(tet.a,tet.b,pt,tet.d);
			const v3 = signedTetraVolume(tet.a,tet.b,tet.c,pt);
			// allow relative epsilon based on tetra volume magnitude
			const tol = 1e-4 * Math.max(1, Math.abs(v));
			const sumDiff = Math.abs(v - (v0+v1+v2+v3));
			if(sumDiff > tol) return false;
			// require sub-volumes have same sign (or zero)
			const signs = [v0, v1, v2, v3].map(x=> Math.sign(x));
			const allNonNeg = signs.every(s=> s >= 0);
			const allNonPos = signs.every(s=> s <= 0);
			return allNonNeg || allNonPos;
		}

		function isBlockedByWorld(pos){
			// pos: {x,y,z} center of player sphere
			for(const obj of objects){
				if(!(obj.isworld || obj.iswall)) continue;
				if(!obj.tetrahedrons) continue;
				for(const tet of obj.tetrahedrons){
					if(sphereIntersectsTetra(pos, player.radius, tet)) return true;
				}
			}
			return false;
		}

		// renderStage implementation replaced by renderer.render()



		// helper: shade a hex color by factor (0..1)
		function shadeColor(hex, factor){
			const c = hex.replace('#','');
			const num = parseInt(c,16);
			let r = (num >> 16) & 0xff;
			let g = (num >> 8) & 0xff;
			let b = num & 0xff;
			r = Math.round(r * factor); g = Math.round(g * factor); b = Math.round(b * factor);
			return `rgb(${r},${g},${b})`;
		}

		function hexToRgba(hex, alpha){
			const c = hex.replace('#','');
			const num = parseInt(c,16);
			let r = (num >> 16) & 0xff;
			let g = (num >> 8) & 0xff;
			let b = num & 0xff;
			return `rgba(${r},${g},${b},${alpha})`;
		}

		// handle click selection using renderer
		canvas.addEventListener('click', (ev)=>{
			const rect = canvas.getBoundingClientRect();
		 	const x = (ev.clientX - rect.left);
		 	const y = (ev.clientY - rect.top);
		 	const obj = renderer.getObjectAtScreen(x,y);
		 	if(!obj){
		 		selectedId = null; selectedInfo.textContent = 'No selection'; const ex = document.getElementById('zControl'); if(ex) ex.remove(); renderer.render(); return;
		 	}
		 	selectObject(obj.id);
		});

		// ---------- input and physics loop ----------
		document.addEventListener('keydown',(e)=>{
			if(e.repeat) return;
			const k = e.key.toLowerCase();
			keysDown.add(k);
			// inventory toggle
			if(k === 'e'){
				inventoryOpen = !inventoryOpen;
				console.log('Inventory',inventoryOpen);
			}
			// interact: if chest is centered, open/close lid on 'q'
			if(k === 'q'){
				const obj = typeof getObjectInCenter === 'function' ? getObjectInCenter() : null;
				if(obj){
					if(obj.name && obj.name.toLowerCase() === 'chest'){
						// toggle open target
						if(!obj.opened){ obj.opened = true; obj.lidTarget = -Math.PI * 0.65; }
						else { obj.opened = false; obj.lidTarget = 0; }
						console.log('Chest state ->', obj.opened ? 'opening' : 'closing');
					} else {
						// default interact: add a property interactions++
						obj.interactions = (obj.interactions||0) + 1;
						console.log('Interacted with',obj.name,obj.interactions);
					}
				}
			}
			// other object-defined keys (zxc... etc)
			const center = typeof getObjectInCenter === 'function' ? getObjectInCenter() : null;
			if(center && center.actions){
				for(const a of center.actions){
					if(a.key === k){
						console.log('Action',a.name,'on',center.name);
						// custom: mark lastAction
						center.lastAction = a.name;
					}
				}
			}
		});

		document.addEventListener('keyup',(e)=>{
			keysDown.delete(e.key.toLowerCase());
		});

		let lastFrame = performance.now();

		function physicsStep(now){
			const dt = Math.max(0, Math.min(0.05, (now - lastFrame)/1000));
			lastFrame = now;

			// controls: arrows to look (adjust player rotation), WASD to move relative to player rotation
			// camera rotation (arrow keys) — camera drives player orientation
			if(keysDown.has('arrowleft')){ camera.rotY = (camera.rotY || 0) - 2.5 * dt; }
			if(keysDown.has('arrowright')){ camera.rotY = (camera.rotY || 0) + 2.5 * dt; }
			if(keysDown.has('arrowup')){ camera.rotX = Math.max(-1.2,(camera.rotX||0) - 2.5 * dt); }
			if(keysDown.has('arrowdown')){ camera.rotX = Math.min(1.2,(camera.rotX||0) + 2.5 * dt); }
			// sync player orientation to camera
			player.rotY = camera.rotY || 0;
			player.pitch = camera.rotX || 0;

			// movement vector in local space
			let mvx=0, mvz=0;
			if(keysDown.has('w')) mvz += 1;
			if(keysDown.has('s')) mvz -= 1;
			if(keysDown.has('a')) mvx -= 1;
			if(keysDown.has('d')) mvx += 1;
			const len = Math.hypot(mvx,mvz);
			if(len>0){ mvx/=len; mvz/=len; }

			// movement is relative to camera forward direction projected flat
			const rot = camera.rotY || 0;
			const forwardX = Math.sin(rot), forwardZ = Math.cos(rot);
			const rightX = Math.cos(rot), rightZ = -Math.sin(rot);
			const worldDX = forwardX * mvz + rightX * mvx;
			const worldDZ = forwardZ * mvz + rightZ * mvx;

			// desired new position (horizontal)
			const speed = player.speed;
			const desired = {x: player.x + worldDX * speed * dt, y: player.y, z: player.z + worldDZ * speed * dt};

			// check horizontal collision by testing player's origin point at desired pos against world/wall tetrahedrons
			if(!isBlockedByWorld({x:desired.x,y:desired.y,z:desired.z})){
				player.x = desired.x; player.z = desired.z;
			}

			// gravity
			const GRAV = 900; // units/s^2
			player.vel.y += GRAV * dt * 1; // downward positive
			player.y += player.vel.y * dt;
			// ground at y=0
			if(player.y >= 0){ player.y = 0; player.vel.y = 0; player.onGround = true; }
			else{ player.onGround = false; }

			// jump (space)
			if(keysDown.has(' ' ) || keysDown.has('space') ){
				if(player.onGround){ player.vel.y = -player.jumpImpulse; player.onGround = false; }
			}

			// animate chest lids towards their target angles
			for(const obj of objects){
				if(obj._lidTemplate){
					const speed = 4.0; // radians per second
					const delta = obj.lidTarget - (obj.lidAngle || 0);
					const maxStep = speed * dt;
					let step = Math.max(-maxStep, Math.min(maxStep, delta));
					obj.lidAngle = (obj.lidAngle || 0) + step;
				}
			}

			// update camera and render via renderer
			renderer.render();
			requestAnimationFrame(physicsStep);
		}

		requestAnimationFrame(physicsStep);

		// helper to get object in center of view via renderer
		function getObjectInCenter(){
			if(typeof renderer !== 'undefined') return renderer.getObjectInCenter();
			return null;
		}


		function renderList(){
			objectList.innerHTML = '';
			objects.forEach(obj=>{
				const row = document.createElement('div');
				row.className = 'object-row';
				row.dataset.id = obj.id;

				const color = document.createElement('div');
				color.className = 'object-color';
				color.style.background = obj.color;

				const meta = document.createElement('div');
				meta.innerHTML = `<div style="font-weight:700">${obj.name}</div><div class="muted">id:${obj.id} — ${Math.round(obj.x)},${Math.round(obj.y)}</div>`;

				row.appendChild(color);
				row.appendChild(meta);

				row.addEventListener('click', ()=> selectObject(obj.id));

				objectList.appendChild(row);
			});
		}

		function selectObject(id){
			selectedId = id;
			const obj = objects.find(o=>o.id === id);
			if(!obj) return;
			// update overlay info
			selectedInfo.textContent = `${obj.name} — ${obj.description}`;
			// add z control when selected
			renderSelectedZControl(obj);
			// visual highlight handled by renderer using selectedId
			// ensure overlay visible
			overlay.style.display = '';
		}

		// render a Z slider for the selected object inside the overlay
		function renderSelectedZControl(obj){
			let existing = document.getElementById('zControl');
			if(existing) existing.remove();
			const wrap = document.createElement('div');
			wrap.id = 'zControl';
			wrap.style.marginTop = '8px';
			wrap.innerHTML = `
				<div style="font-size:13px;margin-bottom:6px">Depth (z): <span id="zValue">${obj.z || 0}</span>px</div>
				<input type="range" id="zRange" min="-600" max="600" step="1" value="${obj.z || 0}" />
			`;

			wrap.querySelector('#zRange').addEventListener('input', (e)=>{
				const v = Number(e.target.value);
				obj.z = v;
				wrap.querySelector('#zValue').textContent = v;
				refresh();
			});

			overlay.appendChild(wrap);
		}

		// helpers
		function addRandomObject(){
			const id = Date.now();
			const x = player.x + (Math.random()-0.5)*400;
			const y = 0; // place on floor
			const z = player.z + (Math.random()*800 + 100);
			const palette = ['#ef4444','#06b6d4','#f97316','#34d399','#a78bfa','#f59e0b'];
			const color = palette[Math.floor(Math.random()*palette.length)];
			const obj = {id,name:`Obj${String(id).slice(-4)}`.replace('id','Obj'),x,y,z,triangles:[],tetrahedrons:[],actions:[],isworld:false,iswall:false,color,description:'A randomly created object'};
			// ensure name exists properly
			obj.name = 'Obj' + (objects.length+1);
			objects.push(obj);
			refresh();
			selectObject(obj.id);
		}

		function clearObjects(){
			// keep player (first object) but clear others
			objects = objects.filter(o=>o.isplayer);
			selectedId = null;
			selectedInfo.textContent = 'No selection';
			refresh();
		}

		function centerSelected(){
			if(!selectedId) return;
			const obj = objects.find(o=>o.id===selectedId);
			if(!obj) return;
			// move selected object near player (center view)
			obj.x = player.x;
			obj.z = player.z + 200;
			obj.y = 0;
			refresh();
			selectObject(obj.id);
		}

		function refresh(){
			renderer.render();
			renderList();
		}

		// events
		toggleOverlayBtn.addEventListener('click', ()=>{
			overlay.style.display = overlay.style.display === 'none' ? '' : 'none';
		});
		addBtn.addEventListener('click', addRandomObject);
		clearBtn.addEventListener('click', clearObjects);
		centerBtn.addEventListener('click', centerSelected);

		// click stage to deselect
		stage.addEventListener('click', ()=>{
			selectedId = null;
			selectedInfo.textContent = 'No selection';
			const ex = document.getElementById('zControl'); if(ex) ex.remove();
			renderer.render();
		});

		// initial render
		refresh();

		// responsive: re-render on resize to keep positions within bounds
		window.addEventListener('resize', ()=>{
			// clamp objects into visible area
			objects.forEach(o=>{
				o.x = Math.max(30, Math.min(stage.clientWidth-30, o.x));
				o.y = Math.max(30, Math.min(stage.clientHeight-30, o.y));
			});
			refresh();
		});
	</script>
</body>
</html>
