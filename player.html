<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Player — Objects & Overlay</title>
	<style>
		:root{--bg:#0f1721;--card:#0b1220;--accent:#06b6d4;--muted:#94a3b8}
	html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;color:#e6eef6;background:linear-gradient(180deg,#071022 0%,#071a2a 100%);overflow:hidden}
	.container{display:flex;flex-direction:column;height:100vh;overflow:hidden}
		header{padding:12px 16px;display:flex;align-items:center;gap:12px}
		h1{font-size:18px;margin:0;color:var(--accent)}
		.toolbar{margin-left:auto;display:flex;gap:8px}
		button{background:var(--card);border:1px solid rgba(255,255,255,0.04);color:#dff7ff;padding:8px 10px;border-radius:8px;cursor:pointer}
	main{flex:1;display:flex;gap:12px;padding:12px;min-height:0;box-sizing:border-box}
		/* game area */
	.stage{flex:1;background:rgba(255,255,255,0.02);border-radius:10px;position:relative;overflow:hidden;border:1px solid rgba(255,255,255,0.03)}
	/* canvas should fill the stage without causing scrollbars */
	#canvas{position:absolute;left:0;top:0;width:100%;height:100%;display:block}
		.grid{position:absolute;inset:0;background-image:linear-gradient(rgba(255,255,255,0.01) 1px, transparent 1px),linear-gradient(90deg,rgba(255,255,255,0.01) 1px, transparent 1px);background-size:40px 40px,40px 40px}
		.obj{position:absolute;width:56px;height:56px;border-radius:8px;display:flex;align-items:center;justify-content:center;color:#041826;font-weight:700;cursor:pointer;box-shadow:0 4px 12px rgba(2,6,23,0.6);transform:translate(-50%,-50%)}
		/* overlay */
		.overlay{position:fixed;right:16px;top:16px;width:320px;max-width:calc(100% - 40px);background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0.02));backdrop-filter:blur(6px);border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.04)}
		.overlay h2{margin:0 0 8px 0;font-size:15px;color:var(--accent)}
		.overlay .meta{font-size:13px;color:var(--muted);margin-bottom:8px}
		.object-list{display:flex;flex-direction:column;gap:6px;max-height:220px;overflow:auto}
		.object-row{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);cursor:pointer}
		.object-color{width:32px;height:32px;border-radius:6px;flex:0 0 32px}
		.muted{color:var(--muted);font-size:13px}
		footer{padding:8px 16px;font-size:13px;color:var(--muted)}
		@media (max-width:600px){.overlay{position:fixed;left:8px;right:8px;top:auto;bottom:8px;width:auto}}
	</style>
</head>
<body>
	<div class="container">
		<header>
			<h1>Player — Objects Preview</h1>
			<div class="toolbar">
				<button id="addBtn">Add random object</button>
				<button id="toggleOverlay">Toggle overlay</button>
			</div>
		</header>

		<main>
			<section class="stage" id="stage" aria-label="Game stage">
				<canvas id="canvas" aria-label="3D canvas renderer"></canvas>
				<div class="grid" aria-hidden="true"></div>
			</section>

			<!-- overlay: object details + list -->
			<aside class="overlay" id="overlay">
				<h2>Objects</h2>
				<div class="meta">Click an object on the stage to view details here.</div>
				<div class="object-list" id="objectList" role="list"></div>
				<div style="margin-top:8px;display:flex;gap:8px;justify-content:space-between;align-items:center">
					<div class="muted" id="selectedInfo">No selection</div>
					<div style="display:flex;gap:8px">
						<button id="centerBtn">Center selected</button>
						<button id="clearBtn">Clear objects</button>
					</div>
				</div>
			</aside>
		</main>

		<footer>
			This demo renders an objects array and shows an overlay with details. Open this file in a browser to interact.
		</footer>
	</div>

	<script>
		// Objects now have richer structure:
		// { id, name, x,y,z (origin), triangles: [{p1:{x,y,z}, p2, p3}], tetrahedrons: [{a,b,c,d}], actions: [{key,name}], flags: isplayer,isworld,iswall }
		let objects = [
			{
				id:1,
				name:'Player',
				x:300,y:100,z:200,
				triangles:[],
				tetrahedrons:[],
				actions:[],
				isplayer:true
			},
			{
				id:2,
				name:'Wall',
				x:500,y:0,z:400,
				triangles:[],
				// simple tetrahedron (four points) in world coords
				tetrahedrons:[
					{a:{x:480,y:0,z:380},b:{x:520,y:0,z:380},c:{x:520,y:100,z:420},d:{x:480,y:100,z:420}}
				],
				actions:[{key:'q',name:'inspect'}],
				isworld:true,
				iswall:true,
				color:'#94a3b8',
				description:'A simple wall tetrahedron'
			},
			{
				id:3,
				name:'Chest',
				x:300,y:0,z:500,
				triangles:[],
				tetrahedrons:[{a:{x:280,y:0,z:480},b:{x:320,y:0,z:480},c:{x:320,y:60,z:520},d:{x:280,y:60,z:520}}],
				actions:[{key:'q',name:'open'}, {key:'z',name:'special'}],
				isworld:false,
				iswall:false,
				color:'#f59e0b',
				description:'A treasure chest with loot.'
			}
		];

		// find player reference and set up player physics state
		let player = objects.find(o=>o.isplayer);
		if(!player){
			player = {id:0,name:'Player',x:300,y:100,z:200,triangles:[],tetrahedrons:[],actions:[],isplayer:true};
			objects.unshift(player);
		}
		player.vel = {x:0,y:0,z:0};
		player.speed = 120; // units per second
		player.jumpImpulse = 320;
		player.onGround = false;

		// input state
		const keysDown = new Set();

		// simple inventory
		let inventoryOpen = false;


		const stage = document.getElementById('stage');
		const canvas = document.getElementById('canvas');
		const ctx = canvas.getContext('2d');
		const objectList = document.getElementById('objectList');
		const overlay = document.getElementById('overlay');
		const toggleOverlayBtn = document.getElementById('toggleOverlay');
		const addBtn = document.getElementById('addBtn');
		const clearBtn = document.getElementById('clearBtn');
		const centerBtn = document.getElementById('centerBtn');
		const selectedInfo = document.getElementById('selectedInfo');

		let selectedId = null;

		// (renderer will handle canvas resizing and drawing)

		const Camera = function(){
			this.x = 0; this.y = 0; this.z = -700; // camera placed behind origin
			this.rotX = 0; this.rotY = 0; // radians
			this.fov = 60; // degrees
			this.focal = 1 / Math.tan((this.fov/2) * Math.PI/180) * 500; // rough focal length
		}

		Camera.prototype.updateFocal = function(){
			this.focal = 1 / Math.tan((this.fov/2) * Math.PI/180) * 500;
		}

		const camera = new Camera();

		// ---------- Renderer: encapsulates canvas-based 3D rendering ----------
		class Renderer {
			constructor(canvas, ctx, camera, objects, player){
				this.canvas = canvas; this.ctx = ctx; this.camera = camera; this.objects = objects; this.player = player;
				this.dpr = window.devicePixelRatio || 1;
			}

			resize(){
				this.dpr = window.devicePixelRatio || 1;
				this.canvas.width = Math.max(300, stage.clientWidth) * this.dpr;
				this.canvas.height = Math.max(150, stage.clientHeight) * this.dpr;
				this.canvas.style.width = stage.clientWidth + 'px';
				this.canvas.style.height = stage.clientHeight + 'px';
				this.ctx.setTransform(this.dpr,0,0,this.dpr,0,0);
			}

			projectPoint(pt){
				const cx = this.canvas.width/2 / (window.devicePixelRatio||1);
				const cy = this.canvas.height/2 / (window.devicePixelRatio||1);
				let x = pt.x - this.camera.x;
				let y = pt.y - this.camera.y;
				let z = pt.z - this.camera.z;

				const cosY = Math.cos(this.camera.rotY), sinY = Math.sin(this.camera.rotY);
				let rx = x * cosY - z * sinY;
				let rz = x * sinY + z * cosY;

				const cosX = Math.cos(this.camera.rotX), sinX = Math.sin(this.camera.rotX);
				let ry = y * cosX - rz * sinX;
				let rlz = y * sinX + rz * cosX;

				if(rlz <= 5) return null;
				const scale = this.camera.focal / rlz;
				return {x: cx + rx * scale, y: cy + ry * scale, scale: scale, z: rlz};
			}

			// draw a floor grid at y=0
			drawFloor(){
				const ctx = this.ctx;
				ctx.save();
				ctx.lineWidth = 1;
				ctx.strokeStyle = 'rgba(255,255,255,0.04)';
				// grid spacing and extents
				const spacing = 100;
				const extent = 2000;
				for(let z = -extent; z<=extent; z+=spacing){
					const a = this.projectPoint({x:-extent,y:0,z:z});
					const b = this.projectPoint({x:extent,y:0,z:z});
					if(a && b){ ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); }
				}
				for(let x = -extent; x<=extent; x+=spacing){
					const a = this.projectPoint({x:x,y:0,z:-extent});
					const b = this.projectPoint({x:x,y:0,z:extent});
					if(a && b){ ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); }
				}
				ctx.restore();
			}

			drawTetrahedrons(){
				const ctx = this.ctx;
				for(const obj of this.objects){
					if(!obj.tetrahedrons) continue;
					for(const tet of obj.tetrahedrons){
						const faces = [[tet.a,tet.b,tet.c],[tet.a,tet.b,tet.d],[tet.a,tet.c,tet.d],[tet.b,tet.c,tet.d]];
						for(const face of faces){
									const pa = this.projectPoint(face[0]);
									const pb = this.projectPoint(face[1]);
									const pc = this.projectPoint(face[2]);
									if(!pa||!pb||!pc) continue;
									ctx.beginPath(); ctx.moveTo(pa.x,pa.y); ctx.lineTo(pb.x,pb.y); ctx.lineTo(pc.x,pc.y); ctx.closePath();
									// fill face with slight transparency for volume perception
									ctx.fillStyle = hexToRgba(obj.color||'#888', 0.08);
									ctx.fill();
									ctx.strokeStyle = (obj.color||'#888'); ctx.lineWidth = 1; ctx.stroke();
						}
					}
				}
			}

			drawObjects(){
				const ctx = this.ctx;
				const projected = this.objects.map(o=>({o,p:this.projectPoint(o)})).filter(x=>x.p);
				projected.sort((a,b)=>b.p.z - a.p.z);
				for(const item of projected){
					const o = item.o, p = item.p; const size = 56 * p.scale;
					ctx.save(); ctx.translate(p.x,p.y);
					const shade = Math.max(0.2, Math.min(1, 1 - (p.z/2000)));
					ctx.fillStyle = shadeColor(o.color||'#06b6d4', shade);
					roundedRect(ctx, -size/2, -size/2, size, size, Math.max(4, size*0.12)); ctx.fill();
					ctx.fillStyle = '#042028'; ctx.font = `${Math.max(10, 12 * p.scale)}px sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
					ctx.fillText(o.name[0]||'?',0,0);
					if(selectedId === o.id){ ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.stroke(); }
					ctx.restore();
				}
			}

			render(){
				this.resize(); this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
				// update camera: place inside top-center-front of player (eye position)
				const eyeHeight = 40; // above player origin
				const forwardOffset = 30; // in front of player
				const rot = this.player.rotY || 0;
				this.camera.x = this.player.x + Math.sin(rot) * forwardOffset;
				this.camera.z = this.player.z + Math.cos(rot) * forwardOffset;
				this.camera.y = this.player.y + eyeHeight;
				// camera orientation follows player view
				this.camera.rotY = this.player.rotY || 0;
				this.camera.rotX = this.player.pitch || 0;
				this.drawFloor(); this.drawTetrahedrons(); this.drawObjects();
			}

			getObjectAtScreen(x,y){
				const hits = [];
				for(const o of this.objects){
					const p = this.projectPoint(o); if(!p) continue; const size = 56 * p.scale;
					if(x >= p.x - size/2 && x <= p.x + size/2 && y >= p.y - size/2 && y <= p.y + size/2) hits.push({o,p});
				}
				hits.sort((a,b)=>a.p.z - b.p.z); return hits.length?hits[0].o:null;
			}

			getObjectInCenter(){
				const rect = this.canvas.getBoundingClientRect(); const cx = rect.width/2; const cy = rect.height/2;
				return this.getObjectAtScreen(cx,cy);
			}
		}

		const renderer = new Renderer(canvas, ctx, camera, objects, player);
		// project function is provided by renderer

		// ---------- collision helpers ----------
		// signed volume of tetrahedron (a,b,c,d)
		function signedTetraVolume(a,b,c,d){
			const ax = a.x-d.x, ay = a.y-d.y, az = a.z-d.z;
			const bx = b.x-d.x, by = b.y-d.y, bz = b.z-d.z;
			const cx = c.x-d.x, cy = c.y-d.y, cz = c.z-d.z;
			return (ax * (by*cz - bz*cy) - ay * (bx*cz - bz*cx) + az * (bx*cy - by*cx)) / 6;
		}

		function pointInTetra(pt, tet){
			// using barycentric volumes: point is inside if all sub-volumes have same sign and sum equals vol
			const v = signedTetraVolume(tet.a,tet.b,tet.c,tet.d);
			const v0 = signedTetraVolume(pt,tet.b,tet.c,tet.d);
			const v1 = signedTetraVolume(tet.a,pt,tet.c,tet.d);
			const v2 = signedTetraVolume(tet.a,tet.b,pt,tet.d);
			const v3 = signedTetraVolume(tet.a,tet.b,tet.c,pt);
			// allow relative epsilon based on tetra volume magnitude
			const tol = 1e-4 * Math.max(1, Math.abs(v));
			const sumDiff = Math.abs(v - (v0+v1+v2+v3));
			if(sumDiff > tol) return false;
			// require sub-volumes have same sign (or zero)
			const signs = [v0, v1, v2, v3].map(x=> Math.sign(x));
			const allNonNeg = signs.every(s=> s >= 0);
			const allNonPos = signs.every(s=> s <= 0);
			return allNonNeg || allNonPos;
		}

		function isBlockedByWorld(pos){
			// pos: {x,y,z}
			for(const obj of objects){
				if(!(obj.isworld || obj.iswall)) continue;
				if(!obj.tetrahedrons) continue;
				for(const tet of obj.tetrahedrons){
					if(pointInTetra(pos,tet)) return true;
				}
			}
			return false;
		}

		// renderStage implementation replaced by renderer.render()

		// helper: rounded rectangle path
		function roundedRect(ctx,x,y,w,h,r){
			const radius = r;
			ctx.beginPath();
			ctx.moveTo(x+radius,y);
			ctx.arcTo(x+w,y,x+w,y+h,radius);
			ctx.arcTo(x+w,y+h,x,y+h,radius);
			ctx.arcTo(x,y+h,x,y,radius);
			ctx.arcTo(x,y,x+w,y,radius);
			ctx.closePath();
		}

		// helper: shade a hex color by factor (0..1)
		function shadeColor(hex, factor){
			const c = hex.replace('#','');
			const num = parseInt(c,16);
			let r = (num >> 16) & 0xff;
			let g = (num >> 8) & 0xff;
			let b = num & 0xff;
			r = Math.round(r * factor); g = Math.round(g * factor); b = Math.round(b * factor);
			return `rgb(${r},${g},${b})`;
		}

		function hexToRgba(hex, alpha){
			const c = hex.replace('#','');
			const num = parseInt(c,16);
			let r = (num >> 16) & 0xff;
			let g = (num >> 8) & 0xff;
			let b = num & 0xff;
			return `rgba(${r},${g},${b},${alpha})`;
		}

		// handle click selection using renderer
		canvas.addEventListener('click', (ev)=>{
			const rect = canvas.getBoundingClientRect();
		 	const x = (ev.clientX - rect.left);
		 	const y = (ev.clientY - rect.top);
		 	const obj = renderer.getObjectAtScreen(x,y);
		 	if(!obj){
		 		selectedId = null; selectedInfo.textContent = 'No selection'; const ex = document.getElementById('zControl'); if(ex) ex.remove(); renderer.render(); return;
		 	}
		 	selectObject(obj.id);
		});

		// ---------- input and physics loop ----------
		document.addEventListener('keydown',(e)=>{
			if(e.repeat) return;
			const k = e.key.toLowerCase();
			keysDown.add(k);
			// inventory toggle
			if(k === 'e'){
				inventoryOpen = !inventoryOpen;
				console.log('Inventory',inventoryOpen);
			}
			// interact
			if(k === 'q'){
				const obj = getObjectInCenter();
				if(obj){
					// default interact: add a property interactions++
					obj.interactions = (obj.interactions||0) + 1;
					console.log('Interacted with',obj.name,obj.interactions);
				}
			}
			// other object-defined keys (zxc... etc)
			const center = typeof getObjectInCenter === 'function' ? getObjectInCenter() : null;
			if(center && center.actions){
				for(const a of center.actions){
					if(a.key === k){
						console.log('Action',a.name,'on',center.name);
						// custom: mark lastAction
						center.lastAction = a.name;
					}
				}
			}
		});

		document.addEventListener('keyup',(e)=>{
			keysDown.delete(e.key.toLowerCase());
		});

		let lastFrame = performance.now();

		function physicsStep(now){
			const dt = Math.max(0, Math.min(0.05, (now - lastFrame)/1000));
			lastFrame = now;

			// controls: arrows to look (adjust player rotation), WASD to move relative to player rotation
			if(keysDown.has('arrowleft')){ player.rotY = (player.rotY || 0) - 2.5 * dt; }
			if(keysDown.has('arrowright')){ player.rotY = (player.rotY || 0) + 2.5 * dt; }
			if(keysDown.has('arrowup')){ player.pitch = Math.max(-1.2,(player.pitch||0) - 2.5 * dt); }
			if(keysDown.has('arrowdown')){ player.pitch = Math.min(1.2,(player.pitch||0) + 2.5 * dt); }

			// movement vector in local space
			let mvx=0, mvz=0;
			if(keysDown.has('w')) mvz += 1;
			if(keysDown.has('s')) mvz -= 1;
			if(keysDown.has('a')) mvx -= 1;
			if(keysDown.has('d')) mvx += 1;
			const len = Math.hypot(mvx,mvz);
			if(len>0){ mvx/=len; mvz/=len; }

			// rotate movement by player.rotY
			const rot = player.rotY || 0;
			const sinR = Math.sin(rot), cosR = Math.cos(rot);
			const worldDX = mvx * cosR - mvz * sinR;
			const worldDZ = mvx * sinR + mvz * cosR;

			// desired new position (horizontal)
			const speed = player.speed;
			const desired = {x: player.x + worldDX * speed * dt, y: player.y, z: player.z + worldDZ * speed * dt};

			// check horizontal collision by testing player's origin point at desired pos against world/wall tetrahedrons
			if(!isBlockedByWorld({x:desired.x,y:desired.y,z:desired.z})){
				player.x = desired.x; player.z = desired.z;
			}

			// gravity
			const GRAV = 900; // units/s^2
			player.vel.y += GRAV * dt * 1; // downward positive
			player.y += player.vel.y * dt;
			// ground at y=0
			if(player.y >= 0){ player.y = 0; player.vel.y = 0; player.onGround = true; }
			else{ player.onGround = false; }

			// jump (space)
			if(keysDown.has(' ' ) || keysDown.has('space') ){
				if(player.onGround){ player.vel.y = -player.jumpImpulse; player.onGround = false; }
			}

			// update camera and render via renderer
			renderer.render();
			requestAnimationFrame(physicsStep);
		}

		requestAnimationFrame(physicsStep);

		// helper to get object in center of view via renderer
		function getObjectInCenter(){
			if(typeof renderer !== 'undefined') return renderer.getObjectInCenter();
			return null;
		}


		function renderList(){
			objectList.innerHTML = '';
			objects.forEach(obj=>{
				const row = document.createElement('div');
				row.className = 'object-row';
				row.dataset.id = obj.id;

				const color = document.createElement('div');
				color.className = 'object-color';
				color.style.background = obj.color;

				const meta = document.createElement('div');
				meta.innerHTML = `<div style="font-weight:700">${obj.name}</div><div class="muted">id:${obj.id} — ${Math.round(obj.x)},${Math.round(obj.y)}</div>`;

				row.appendChild(color);
				row.appendChild(meta);

				row.addEventListener('click', ()=> selectObject(obj.id));

				objectList.appendChild(row);
			});
		}

		function selectObject(id){
			selectedId = id;
			const obj = objects.find(o=>o.id === id);
			if(!obj) return;
			// update overlay info
			selectedInfo.textContent = `${obj.name} — ${obj.description}`;
			// add z control when selected
			renderSelectedZControl(obj);
			// visual highlight handled by renderer using selectedId
			// ensure overlay visible
			overlay.style.display = '';
		}

		// render a Z slider for the selected object inside the overlay
		function renderSelectedZControl(obj){
			let existing = document.getElementById('zControl');
			if(existing) existing.remove();
			const wrap = document.createElement('div');
			wrap.id = 'zControl';
			wrap.style.marginTop = '8px';
			wrap.innerHTML = `
				<div style="font-size:13px;margin-bottom:6px">Depth (z): <span id="zValue">${obj.z || 0}</span>px</div>
				<input type="range" id="zRange" min="-600" max="600" step="1" value="${obj.z || 0}" />
			`;

			wrap.querySelector('#zRange').addEventListener('input', (e)=>{
				const v = Number(e.target.value);
				obj.z = v;
				wrap.querySelector('#zValue').textContent = v;
				refresh();
			});

			overlay.appendChild(wrap);
		}

		// helpers
		function addRandomObject(){
			const id = Date.now();
			const x = player.x + (Math.random()-0.5)*400;
			const y = 0; // place on floor
			const z = player.z + (Math.random()*800 + 100);
			const palette = ['#ef4444','#06b6d4','#f97316','#34d399','#a78bfa','#f59e0b'];
			const color = palette[Math.floor(Math.random()*palette.length)];
			const obj = {id,name:`Obj${String(id).slice(-4)}`.replace('id','Obj'),x,y,z,triangles:[],tetrahedrons:[],actions:[],isworld:false,iswall:false,color,description:'A randomly created object'};
			// ensure name exists properly
			obj.name = 'Obj' + (objects.length+1);
			objects.push(obj);
			refresh();
			selectObject(obj.id);
		}

		function clearObjects(){
			// keep player (first object) but clear others
			objects = objects.filter(o=>o.isplayer);
			selectedId = null;
			selectedInfo.textContent = 'No selection';
			refresh();
		}

		function centerSelected(){
			if(!selectedId) return;
			const obj = objects.find(o=>o.id===selectedId);
			if(!obj) return;
			// move selected object near player (center view)
			obj.x = player.x;
			obj.z = player.z + 200;
			obj.y = 0;
			refresh();
			selectObject(obj.id);
		}

		function refresh(){
			renderer.render();
			renderList();
		}

		// events
		toggleOverlayBtn.addEventListener('click', ()=>{
			overlay.style.display = overlay.style.display === 'none' ? '' : 'none';
		});
		addBtn.addEventListener('click', addRandomObject);
		clearBtn.addEventListener('click', clearObjects);
		centerBtn.addEventListener('click', centerSelected);

		// click stage to deselect
		stage.addEventListener('click', ()=>{
			selectedId = null;
			selectedInfo.textContent = 'No selection';
			const ex = document.getElementById('zControl'); if(ex) ex.remove();
			renderer.render();
		});

		// initial render
		refresh();

		// responsive: re-render on resize to keep positions within bounds
		window.addEventListener('resize', ()=>{
			// clamp objects into visible area
			objects.forEach(o=>{
				o.x = Math.max(30, Math.min(stage.clientWidth-30, o.x));
				o.y = Math.max(30, Math.min(stage.clientHeight-30, o.y));
			});
			refresh();
		});
	</script>
</body>
</html>
